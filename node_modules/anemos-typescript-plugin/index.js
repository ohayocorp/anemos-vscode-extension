const fs = require('fs');
const path = require('path');

/**
 * Plugin factory function.
 * @param {Object} modules - The modules object provided by TypeScript.
 * @returns {Object} - The plugin object.
 */
function init(modules) {
    const { typescript: ts } = modules;

    // Cache for resolved modules.
    const resolvedModuleCache = new Map();

    /**
     * Creates the language service.
     * @param {Object} info - Plugin creation info from TypeScript.
     * @returns {Object} - TypeScript language service.
     */
    function create(info) {
        const logger = {
            log: (msg) => info.project.projectService.logger.info(`[anemos-typescript-plugin] ${msg}`),
            error: (err) => info.project.projectService.logger.info(`[anemos-typescript-plugin] ERROR: ${err.message || err}`)
        };

        const directory = info.project.getCurrentDirectory();
        
        const extensionTypesDir = getExtensionTypesDirectory();
        logger.log(`Plugin initialized in directory: ${directory}.`);
        logger.log(`Types directory: ${extensionTypesDir}.`);

        // Create a language service host proxy.
        const languageServiceHost = {};

        const languageServiceHostProxy = new Proxy(info.languageServiceHost, {
            get(target, key) {
                return languageServiceHost[key]
                    ? languageServiceHost[key]
                    : target[key];
            }
        });

        // Create the language service.
        const languageService = ts.createLanguageService(languageServiceHostProxy);

        // Check if a module is an Anemos module.
        const isAnemosModule = (moduleName) => {
            return moduleName === "@ohayocorp/anemos" || moduleName.startsWith("@ohayocorp/anemos/");
        };

        // Implement module resolution for TypeScript 5.x.
        if (info.languageServiceHost.resolveModuleNameLiterals) {
            const originalResolveModuleNameLiterals =
                info.languageServiceHost.resolveModuleNameLiterals.bind(info.languageServiceHost);

            languageServiceHost.resolveModuleNameLiterals = function (moduleNames, containingFile, ...rest) {
                logger.log(`Resolving module literals: ${moduleNames.map(m => m.text).join(", ")}.`);

                // Let TypeScript try to resolve the modules first.
                const resolvedModules = originalResolveModuleNameLiterals(
                    moduleNames,
                    containingFile,
                    ...rest
                );

                return moduleNames.map(({ text: moduleName }, index) => {
                    try {
                        // Only intercept if it's an Anemos module and TypeScript couldn't resolve it.
                        if (isAnemosModule(moduleName) && !resolvedModules[index].resolvedModule) {
                            
                            // Check if it's already in our cache.
                            const cacheKey = `${moduleName}:${containingFile}`;
                            if (resolvedModuleCache.has(cacheKey)) {
                                return { resolvedModule: resolvedModuleCache.get(cacheKey) };
                            }

                            // Check for declaration file in our types directory.
                            const subpath = moduleName === "@ohayocorp/anemos"
                                ? "index.d.ts"
                                : `${moduleName.substring("@ohayocorp/anemos/".length)}.d.ts`;

                            const typePath = path.join(extensionTypesDir, subpath);

                            if (fs.existsSync(typePath)) {
                                logger.log(`Resolving ${moduleName} to type at ${typePath}.`);

                                const resolvedModule = {
                                    resolvedFileName: typePath,
                                    isExternalLibraryImport: true,
                                    extension: ts.Extension.Dts
                                };

                                resolvedModuleCache.set(cacheKey, resolvedModule);
                                return { resolvedModule };
                            }
                        }
                    } catch (e) {
                        logger.error(e);
                    }

                    return resolvedModules[index];
                });
            };
        }
        // Implement module resolution for TypeScript 4.x.
        else if (info.languageServiceHost.resolveModuleNames) {
            const originalResolveModuleNames =
                info.languageServiceHost.resolveModuleNames.bind(info.languageServiceHost);

            languageServiceHost.resolveModuleNames = function (moduleNames, containingFile, ...rest) {
                logger.log(`Resolving modules: ${moduleNames.join(", ")}.`);

                // Call original implementation first to see if TypeScript can resolve the modules.
                const originalResolutions = originalResolveModuleNames(
                    moduleNames,
                    containingFile,
                    ...rest
                );

                // Only provide custom resolutions for Anemos modules that TypeScript couldn't resolve.
                return moduleNames.map((moduleName, i) => {
                    // If not an Anemos module or TypeScript resolved it successfully, use TypeScript's resolution.
                    if (!isAnemosModule(moduleName) || originalResolutions[i]) {
                        return originalResolutions[i];
                    }

                    // Check if it's already in our cache.
                    const cacheKey = `${moduleName}:${containingFile}`;
                    if (resolvedModuleCache.has(cacheKey)) {
                        return resolvedModuleCache.get(cacheKey);
                    }

                    // Check for declaration file in our types directory.
                    const subpath = moduleName === "@ohayocorp/anemos"
                        ? "index.d.ts"
                        : `${moduleName.substring("@ohayocorp/anemos/".length)}.d.ts`;

                    const typePath = path.join(extensionTypesDir, subpath);

                    if (fs.existsSync(typePath)) {
                        logger.log(`Resolving ${moduleName} to type at ${typePath}.`);

                        const resolvedModule = {
                            resolvedFileName: typePath,
                            isExternalLibraryImport: true,
                            extension: ts.Extension.Dts
                        };

                        resolvedModuleCache.set(cacheKey, resolvedModule);
                        return resolvedModule;
                    }

                    return originalResolutions[i];
                });
            };
        }

        return languageService;
    }
    
    /**
     * Gets the directory containing extension types.
     * @returns {string} - Path to the extension types directory.
     */
    function getExtensionTypesDirectory() {
        return path.join(__dirname, '.anemos-types');
    }

    return { create };
}

module.exports = init;